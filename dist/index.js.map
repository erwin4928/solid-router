{"version":3,"file":"index.js","sources":["../src/match.ts","../src/Router.tsx","../src/Route.tsx","../src/index.ts"],"sourcesContent":["import type { ParamDefinition, URLParams, Matcher } from './types'\n\nexport type Args<R extends string> =\n  R extends `:${infer P}*?{${infer R}}${infer Flags}/${infer Rest}`\n    ? { [K in P]?: RegexValue<Flags>[] } & Partial<Args<Rest>>\n    : R extends `:${infer P}*{${infer R}}${infer Flags}/${infer Rest}`\n      ? { [K in P]: RegexValue<Flags>[] } & Args<Rest>\n      : R extends `:${infer P}?{${infer R}}${infer Flags}/${infer Rest}`\n        ? { [K in P]?: RegexValue<Flags> } & Args<Rest>\n        : R extends `:${infer P}{${infer R}}${infer Flags}/${infer Rest}`\n          ? { [K in P]: RegexValue<Flags> } & Args<Rest>\n          : R extends `:${infer P}*?/${infer Rest}`\n            ? { [K in P]?: string[] } & Partial<Args<Rest>>\n            : R extends `:${infer P}*/${infer Rest}`\n              ? { [K in P]: string[] } & Args<Rest>\n              : R extends `:${infer P}?/${infer Rest}`\n                ? { [K in P]?: string } & Partial<Args<Rest>>\n                : R extends `:${infer P}/${infer Rest}`\n                  ? { [K in P]: string } & Args<Rest>\n                  : R extends `:${infer P}*?{${infer R}}${infer Flags}`\n                    ? { [K in P]?: RegexValue<Flags>[] }\n                    : R extends `:${infer P}*{${infer R}}${infer Flags}`\n                      ? { [K in P]: RegexValue<Flags>[] }\n                      : R extends `:${infer P}?{${infer R}}${infer Flags}`\n                        ? { [K in P]?: RegexValue<Flags> }\n                        : R extends `:${infer P}{${infer R}}${infer Flags}`\n                          ? { [K in P]: RegexValue<Flags> }\n                          : R extends `:${infer P}*?`\n                            ? { [K in P]?: string[] }\n                            : R extends `:${infer P}*`\n                              ? { [K in P]: string[] }\n                              : R extends `:${infer P}?`\n                                ? { [K in P]?: string }\n                                : R extends `:${infer P}`\n                                  ? { [K in P]: string }\n                                  : {}\n\nexport type RegexValue<Flags> = Flags extends `${infer L}g${infer T}` ? RegExpExecArray : RegExpMatchArray\n\nlet params_regex = /(?:^|\\/)(:?)([^*?{}/]+)(\\*)?(\\?)?(?:{(.+)}([a-z]*)?)?/g\nlet segments_regex = /([^/]+)/g\n\nexport let create_matcher = (route: string): Matcher => {\n  let param_defs: ParamDefinition[] = []\n  let matched: RegExpExecArray | null\n  let pk = 0\n  let weight = 0\n\n  while (matched = params_regex.exec(route)) {\n    let [_, not_static, name, wild, optional, regex, flags] = matched\n\n    if (!not_static && !!wild) { // static and wild unsupported\n      wild = ''\n    }\n\n    if (!not_static && regex) { // static and regex unsupported\n      regex = ''\n    }\n\n    weight++\n\n    if (!not_static) {\n      weight++\n    }\n\n    let param: ParamDefinition = {\n      name,\n      static: !not_static,\n      optional: !!optional,\n      wild: !!wild,\n      rightRequired: 0,\n    }\n\n    if (regex) {\n      param.regex = new RegExp(regex, flags)\n    }\n\n    let stop = false\n\n    for (let k = pk - 1; k > -1; k--) {\n      let prev = param_defs[k]\n\n      if (!param.optional && !stop) {\n        prev.rightRequired = ++prev.rightRequired\n      }\n\n      if (prev.optional) {\n        stop = true\n      }\n\n      if (param.wild && !prev.nextWild) {\n        prev.nextWild = param\n      }\n    }\n\n    param_defs[pk++] = param\n  }\n\n  if (!param_defs.length) {\n    return { weight, param_defs, match: () => null }\n  }\n\n  let match = (path: string) => {\n    let segments = path.match(segments_regex)\n\n    if (!segments) {\n      return null\n    }\n\n    let pk = 0\n    let param: ParamDefinition | undefined = param_defs[pk]\n    let args: URLParams = {}\n\n    if (!param.wild && !param.nextWild) {\n      if (segments.length > param_defs.length) {\n        return null\n      }\n    }\n\n    for (let k = 0; k < segments.length; k++) {\n      if (segments.length - 1 - k < param!.rightRequired) { // rightRequired might change when encountering an optional param with additional params\n        return null\n      }\n\n      let seg = segments[k]\n\n      if (param!.static) {\n        if (seg != param!.name) {\n          return null\n        }\n\n        param = param_defs[++pk]\n\n        continue\n      }\n\n      if (!param!.wild) {\n        if (param.regex) {\n          if (param.regex.global) {\n            let match = Array.from(seg.matchAll(param.regex))\n\n            if (!match.length) {\n              return null\n            }\n\n            args[param.name] = match\n          }\n          else {\n            let match = seg.match(param.regex)\n\n            if (!match) {\n              return null\n            }\n\n            args[param.name] = match\n          }\n        }\n        else {\n          args[param!.name] = seg\n        }\n\n        param = param_defs[++pk]\n\n        continue\n      }\n\n      let right: number\n\n      if (param!.nextWild) {\n        right = 0\n      }\n      else {\n        right = segments.length - 1 - k - (param_defs.length - 1 - pk)\n\n        if (right < 0) {\n          right = 0\n        }\n      }\n\n      let wild_args = new Array<string | RegExpMatchArray>(right + 1)\n\n      for (let wk = 0; wk < wild_args.length; wk++) {\n        let seg = segments[k + wk]\n\n        if (param.regex && !param.regex.global) {\n          let match = seg.match(param.regex)\n\n          if (!match) {\n            return null\n          }\n\n          wild_args[wk] = match\n        }\n        else {\n          wild_args[wk] = seg\n        }\n      }\n\n      if (param.regex?.global) {\n        let match = Array.from(wild_args.join('/').matchAll(param.regex))\n\n        if (!match.length) {\n          return null\n        }\n\n        args[param.name] = match\n      }\n      else {\n        args[param!.name] = wild_args as string[]\n      }\n\n      k += wild_args.length - 1\n\n      param = param_defs[++pk]\n    }\n\n    // leftover optional params\n    while (param) {\n      if (param.wild) {\n        args[param.name] = null\n      }\n      else {\n        args[param.name] = null\n      }\n\n      param = param_defs[++pk]\n    }\n\n    return args\n  }\n\n  return { weight, param_defs, match }\n}\n","import { Accessor, children, createContext, createMemo, createRenderEffect, createSignal, getOwner, JSX, on, onCleanup, ParentComponent, resetErrorBoundaries, runWithOwner, startTransition, untrack, useContext } from 'solid-js'\nimport { delegateEvents } from 'solid-js/web'\n\nimport {\n  RouteDefinition,\n  URLParams,\n  Params,\n  State,\n  Branch,\n  Match,\n  Intent,\n  NavigateOptions,\n  Matcher,\n} from './types'\nimport { create_matcher } from './match'\n\nexport interface RouterContext {\n  is_routing: Accessor<boolean>\n  intent: Accessor<Intent>\n  state: [Accessor<State>, (state: unknown) => void]\n  pathname: [Accessor<string>, (pathname: string) => void]\n  search: [Accessor<string>, (search: string) => void]\n  search_params: [Accessor<Params>, (params: Params) => void]\n  hash: [Accessor<string>, (hash: string) => void]\n  url_params: [Accessor<URLParams>, (params: Params) => void]\n  navigate(url: string, options?: NavigateOptions): void\n  navigate(delta: number): void\n}\n\nexport let RouterContext = createContext<RouterContext>()\n\nexport let use_router = () => {\n  let ctx = useContext(RouterContext)\n\n  if (!ctx) {\n    throw new Error()\n  }\n\n  return ctx\n}\n\nexport interface RouteContext {\n  is_routing: Accessor<boolean>\n  intent: Accessor<Intent>\n  state: [Accessor<State>, (state: unknown) => void]\n  pathname: [Accessor<string>, (pathname: string) => void]\n  search: [Accessor<string>, (search: string) => void]\n  search_params: [Params, (params: Params) => void]\n  hash: [Accessor<string>, (hash: string) => void]\n  url_params: [URLParams, (params: Params) => void]\n  component: Accessor<() => JSX.Element>\n}\n\nexport let RouteContext = createContext<RouteContext>()\n\nexport let use_route = () => {\n  let ctx = useContext(RouteContext)\n\n  if (ctx == undefined) {\n    throw new Error()\n  }\n\n  return ctx\n}\n\nexport let Router: ParentComponent = (props) => {\n  let [is_routing, set_is_routing] = createSignal(false)\n  let [intent, set_intent] = createSignal<Intent>('navigate')\n\n  let [pathname, set_pathname] = createSignal(extract_pathname(location.pathname))\n  let [initial_search, initial_search_params] = extract_search(location.search)\n  let [search, set_search] = createSignal(initial_search)\n  let [search_params, set_search_params] = createSignal(initial_search_params)\n  let [hash, set_hash] = createSignal(extract_hash(location.hash))\n\n  navigate(get_state(), pathname() + search() + hash(), true)\n\n  let [state, set_state] = createSignal(get_state(), {\n    equals: (prev, next) => prev.solidRouter.version == next.solidRouter.version && prev.solidRouter.depth == next.solidRouter.depth,\n  })\n\n  let route_defs = children(() => props.children) as () => RouteDefinition | RouteDefinition[] | undefined\n  let branches = createMemo(() => {\n    let defs = route_defs()\n\n    if (!defs) {\n      return []\n    }\n\n    if (!Array.isArray(defs)) {\n      defs = [defs]\n    }\n\n    return create_branches(defs)\n  })\n\n  let [match, set_match] = createSignal(match_branches(pathname(), branches()), {\n    equals: (prev, next) => {\n      if (prev && next) {\n        return prev.branch == next.branch\n      }\n\n      return false\n    },\n  })\n\n  createRenderEffect(on(() => branches(), (branches) => {\n    set_is_routing(true)\n\n    startTransition(() => {\n      set_match(match_branches(pathname(), branches))\n\n      resetErrorBoundaries()\n    }).finally(() => set_is_routing(false))\n  }, { defer: true }))\n\n  let ctx: RouterContext = {\n    is_routing,\n    intent,\n    state: [state, next => untrack(() => {\n      let next_state = state()\n\n      next_state.solidRouter.version++\n      next_state.solidRouter.state = next\n\n      navigate(next_state, pathname() + search() + hash(), true).then(() => {\n        startTransition(() => {\n          set_intent('internal')\n          set_state(get_state())\n          resetErrorBoundaries()\n        })\n      })\n    })],\n    pathname: [pathname, value => untrack(() => {\n      let next_pathname = extract_pathname(value)\n\n      if (next_pathname[0] != '/') {\n        next_pathname = pathname().replace(last_segment_regex, next_pathname)\n      }\n\n      if (next_pathname == pathname()) {\n        return\n      }\n\n      navigate(state(), next_pathname + search() + hash(), true).then(() => {\n        startTransition(() => {\n          set_intent('internal')\n          set_pathname(next_pathname)\n          set_match(match_branches(next_pathname, branches()))\n\n          resetErrorBoundaries()\n        })\n      })\n    })],\n    search: [search, value => untrack(() => {\n      let [next_search, next_search_params] = extract_search(value)\n\n      if (next_search == search()) {\n        return\n      }\n\n      navigate(state(), pathname() + next_search + hash(), true).then(() => {\n        startTransition(() => {\n          set_intent('internal')\n          set_search(next_search)\n          set_search_params(next_search_params)\n\n          resetErrorBoundaries()\n        })\n      })\n    })],\n    hash: [hash, value => untrack(() => {\n      let next_hash = extract_hash(value)\n\n      if (next_hash == hash()) {\n        return\n      }\n\n      navigate(state(), pathname() + search() + next_hash, true).then(() => {\n        startTransition(() => {\n          set_intent('internal')\n          set_hash(next_hash)\n\n          resetErrorBoundaries()\n        })\n      })\n    })],\n    url_params: [createMemo(() => match()?.params || {}), next => untrack(() => {\n      let match_ = match()\n\n      if (!match_?.branch.param_defs) {\n        return\n      }\n\n      let all_params = { ...match_.params, ...next }\n      let next_pathname = ''\n\n      for (let param_def of match_.branch.param_defs) {\n        if (param_def.static) {\n          next_pathname += '/' + param_def.name\n\n          continue\n        }\n\n        let value = all_params[param_def.name]\n\n        if (!value) {\n          if (!param_def.optional) {\n            return\n          }\n\n          break\n        }\n\n        if (param_def.wild) {\n          if (!Array.isArray(value)) {\n            value = [value]\n          }\n\n          if (param_def.nextWild && value.length > 1) {\n            next_pathname += '/' + value[0]\n          }\n          else {\n            next_pathname += '/' + value.join('/')\n          }\n        }\n        else {\n          if (Array.isArray(value)) {\n            next_pathname += '/' + value[0]\n          }\n          else {\n            next_pathname += '/' + value\n          }\n        }\n      }\n\n      if (!next_pathname) {\n        next_pathname = '/'\n      }\n\n      if (next_pathname == pathname()) {\n        return\n      }\n\n      navigate(state(), next_pathname + search() + hash(), true).then(() => {\n        startTransition(() => {\n          set_intent('internal')\n          set_pathname(next_pathname)\n          set_match(match_branches(next_pathname, branches()))\n\n          resetErrorBoundaries()\n        })\n      })\n    })],\n    search_params: [search_params, value => untrack(() => {\n      let [next_search, next_search_params] = extract_search(value)\n\n      if (next_search == search()) {\n        return\n      }\n\n      navigate(state(), pathname() + next_search + hash(), true).then(() => {\n        startTransition(() => {\n          set_intent('internal')\n          set_search(next_search)\n          set_search_params(next_search_params)\n\n          resetErrorBoundaries()\n        })\n      })\n    })],\n    navigate: (url_delta, options?: NavigateOptions) => untrack(() => {\n      if (typeof url_delta == 'number') {\n        navigate(url_delta) // popstate\n\n        return\n      }\n\n      let next_pathname = extract_pathname(url_delta)\n      let next_search: string\n      let next_search_params: Params\n      let next_hash = extract_hash(url_delta)\n\n      if (options?.search_params) {\n        next_search = build_search(options.search_params)\n        next_search_params = options.search_params\n      }\n      else {\n        let [a, b] = extract_search(url_delta)\n\n        next_search = a\n        next_search_params = b\n      }\n\n      if (next_pathname + next_search + next_hash == pathname() + search() + hash()) {\n        if (options?.state === undefined) {\n          return\n        }\n\n        options ??= {}\n        options.replace = true\n      }\n\n      let next_state: State\n\n      if (options?.replace) {\n        next_state = state()\n\n        if (options?.state !== undefined) {\n          next_state.solidRouter.version++\n          next_state.solidRouter.state = options.state\n        }\n      }\n      else {\n        next_state = {\n          solidRouter: {\n            version: 0,\n            state: options?.state,\n            pathname: next_pathname,\n            depth: state().solidRouter.depth + 1,\n            referrer: pathname(),\n          },\n        }\n\n        next_state.solidRouter.pathname = next_pathname\n        next_state.solidRouter.depth++\n        next_state.solidRouter.referrer = pathname()\n      }\n\n      navigate(next_state, url_delta, options?.replace).then(() => {\n        next_state = get_state()\n\n        set_is_routing(true)\n\n        startTransition(() => {\n          set_intent('navigate')\n\n          if (next_pathname != pathname()) {\n            set_pathname(next_pathname)\n            set_match(match_branches(next_pathname, branches()))\n          }\n\n          if (next_search != search()) {\n            set_search(next_search)\n            set_search_params(next_search_params)\n          }\n\n          if (next_hash != hash()) {\n            set_hash(next_hash)\n          }\n\n          if (options?.state !== undefined || !options?.replace) {\n            set_state(next_state)\n          }\n        }).finally(() => set_is_routing(false))\n      })\n    }),\n  }\n\n  let popstate = () => {\n    let next_pathname = extract_pathname(location.pathname)\n    let [next_search, next_search_params] = extract_search(location.search)\n    let next_hash = extract_hash(location.hash)\n    let next_state = get_state()\n\n    startTransition(() => {\n      set_intent('popstate')\n\n      if (next_pathname != pathname()) {\n        set_pathname(next_pathname)\n        set_match(match_branches(next_pathname, branches()))\n      }\n\n      if (next_search != search()) {\n        set_search(next_search)\n        set_search_params(next_search_params)\n      }\n\n      if (next_hash != hash()) {\n        set_hash(next_hash)\n      }\n\n      set_state(next_state)\n\n      resetErrorBoundaries()\n    })\n  }\n\n  window.addEventListener('popstate', popstate)\n\n  onCleanup(() => {\n    window.removeEventListener('popstate', popstate)\n  })\n\n  setup_anchor_events(ctx)\n\n  let matched_branches = createMemo(() => {\n    let leaf = match()\n\n    if (!leaf) {\n      return []\n    }\n\n    let branch = leaf.branch\n    let matched_branches: Branch[] = []\n\n    if (branch.route_def.component) {\n      matched_branches.unshift(branch)\n    }\n\n    while (branch.parent) {\n      if (branch.parent.route_def.component) {\n        matched_branches.unshift(branch.parent)\n      }\n\n      branch = branch.parent\n    }\n\n    return matched_branches\n  })\n\n  let root_component = createMemo(() => matched_branches()[0]?.route_def.component)\n\n  return (\n    <RouterContext.Provider value={ctx}>\n      <Child branches={matched_branches()} key={0} component={root_component() || (() => null)} />\n    </RouterContext.Provider>\n  )\n}\n\ntype ChildProps = {\n  branches: Branch[]\n  key: number\n  component: () => JSX.Element\n}\n\nlet Child = (props: ChildProps) => {\n  let router = use_router()\n\n  let child_component = createMemo(() => props.branches[props.key + 1]?.route_def.component)\n\n  let cache: Partial<Omit<RouteContext, 'component' | 'children'>> = {}\n\n  let ctx: RouteContext = {\n    get is_routing() {\n      return cache.is_routing || (cache.is_routing = lock(router.is_routing, child_component))\n    },\n    get intent() {\n      return cache.intent || (cache.intent = lock(router.intent, child_component))\n    },\n    get state() {\n      return cache.state || (cache.state = [lock(router.state[0], child_component), router.state[1]])\n    },\n    get pathname() {\n      return cache.pathname || (cache.pathname = [lock(router.pathname[0], child_component), router.pathname[1]])\n    },\n    get search() {\n      return cache.search || (cache.search = [lock(router.search[0], child_component), router.search[1]])\n    },\n    get search_params() {\n      return cache.search_params || (cache.search_params = [untrack(() => create_params(lock(router.search_params[0], child_component))), router.search_params[1]])\n    },\n    get hash() {\n      return cache.hash || (cache.hash = [lock(router.hash[0], child_component), router.hash[1]])\n    },\n    get url_params() {\n      return cache.url_params || (cache.url_params = [untrack(() => create_params(lock(router.url_params[0], child_component))), router.url_params[1]])\n    },\n    component: () => {\n      let component = child_component()\n\n      return () => <Child branches={props.branches} key={props.key + 1} component={component || (() => null)} />\n    },\n  }\n\n  return (\n    <RouteContext.Provider value={ctx}>\n      <props.component />\n    </RouteContext.Provider>\n  )\n}\n\nfunction lock<T>(value: Accessor<T>, lock: Accessor<unknown>): Accessor<T> {\n  let prev_lock: unknown\n\n  return createMemo<T>((prev_value) => {\n    if (prev_lock == lock()) {\n      return prev_value\n    }\n\n    prev_lock = lock()\n\n    return value()\n  }, value())\n}\n\nfunction create_params<P extends Params | URLParams>(params: Accessor<P>): P {\n  let owner = getOwner()\n\n  if (owner == null) {\n    throw new Error()\n  }\n\n  let map = new Map()\n\n  let proxy = new Proxy(params(), {\n    get(_, property) {\n      if (typeof property != 'string') {\n        throw new Error()\n      }\n\n      if (!map.has(property)) {\n        runWithOwner(owner, () =>\n          map.set(\n            property,\n            createMemo(() => {\n              let value = params()[property]\n\n              return value\n            }, undefined, {\n              equals: (prev, next) => {\n                if (Array.isArray(prev) && Array.isArray(next)) {\n                  if (next.length != prev.length) {\n                    return false\n                  }\n\n                  for (let k = 0; k < prev.length; k++) {\n                    if (prev[k] != next[k]) {\n                      return false\n                    }\n                  }\n\n                  return true\n                }\n\n                return prev == next\n              },\n            }),\n          ),\n        )\n      }\n\n      return map.get(property)()\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true,\n      }\n    },\n    ownKeys() {\n      return Reflect.ownKeys(params())\n    },\n  })\n\n  return proxy\n}\n\nlet get_state = (depth?: number): State => {\n  let state: State = history.state\n\n  if (state !== null && typeof state == 'object' && 'solid-router' in state) {\n    return state\n  }\n\n  return {\n    solidRouter: {\n      version: 0,\n      pathname: extract_pathname(location.pathname),\n      state,\n      depth: depth || 0,\n    },\n  }\n}\n\nlet double_slash_regex = /\\/\\/+/g\nlet trailing_slash_regex = /\\/$/\nlet pathname_regex = /^(?:http:\\/\\/[^/]*)?([^?#]*)(?:\\?|#)?/\nlet last_segment_regex = /[^/]*$/\n\nlet extract_pathname = (url: string) => {\n  let match = url.match(pathname_regex)\n\n  if (!match) {\n    return '/'\n  }\n\n  return match[1].replaceAll(double_slash_regex, '/').replace(trailing_slash_regex, '')\n}\n\nlet search_regex = /\\?+[^?#]*/\nlet param_regex = /([^?#&=]+)=([^?#&=]+)/g\n\nfunction extract_search(url: string): [string, Params]\nfunction extract_search(params: Params): [string, Params]\nfunction extract_search(url_params: string | Params): [string, Params] {\n  if (typeof url_params == 'string') {\n    let match = url_params.match(search_regex)\n\n    if (!match) {\n      return ['', {}]\n    }\n\n    let search = ''\n    let params: Params = {}\n    let match_arr = match[0].matchAll(param_regex)\n\n    for (let match of match_arr) {\n      let key = match[1]\n      let value = match[2]\n      let prev = params[key]\n\n      if (search) {\n        search += '&'\n      }\n\n      search += `${key}=${value}`\n\n      if (prev) {\n        if (!Array.isArray(prev)) {\n          params[key] = [prev, value]\n        }\n        else {\n          prev.push(value)\n        }\n      }\n      else {\n        params[key] = value\n      }\n    }\n\n    return ['?' + search, params]\n  }\n\n  let search = ''\n  let params: Params = {}\n\n  for (let param in url_params) {\n    let value = url_params[param]\n\n    if (!value) {\n      continue\n    }\n\n    params[param] = value\n\n    if (Array.isArray(value)) {\n      for (let v of value) {\n        if (search.length) {\n          search += '&'\n        }\n\n        search += `${param}=${v}`\n      }\n    }\n    else {\n      if (search.length) {\n        search += '&'\n      }\n\n      search += `${param}=${value}`\n    }\n  }\n\n  if (search.length) {\n    search = '?' + search\n  }\n\n  return [search, params]\n}\n\nlet build_search = (params: Params): string => {\n  let search = ''\n\n  for (let param in params) {\n    let value = params[param]\n\n    if (!value) {\n      continue\n    }\n\n    if (Array.isArray(value)) {\n      for (let v of value) {\n        if (search.length) {\n          search += '&'\n        }\n\n        search += `${param}=${v}`\n      }\n    }\n    else {\n      if (search.length) {\n        search += '&'\n      }\n\n      search += `${param}=${value}`\n    }\n  }\n\n  if (search.length) {\n    search = '?' + search\n  }\n\n  return search\n}\n\nlet hash_regex = /#[^#]+/\n\nlet extract_hash = (url: string) => {\n  let match = url.match(hash_regex)\n\n  if (!match) {\n    return ''\n  }\n\n  return match[0]\n}\n\nlet create_branches = (\n  route_defs: RouteDefinition[],\n  parent?: Branch,\n): Branch[] => {\n  let branches: Branch[] = []\n\n  for (let def of route_defs) {\n    let pattern = ''\n\n    if (def.path) {\n      pattern = def.path.slice(1)\n    }\n\n    if (parent?.pattern) {\n      if (pattern) {\n        pattern = `${parent.pattern}/${pattern}`\n      }\n      else {\n        pattern = parent.pattern\n      }\n    }\n\n    let matcher: Matcher | undefined\n\n    if (pattern) {\n      matcher = create_matcher(pattern)\n    }\n\n    let branch: Branch = {\n      pattern,\n      weight: matcher?.weight || 0,\n      param_defs: matcher?.param_defs || [],\n      route_def: def,\n      parent,\n      match: (path) => {\n        if (!matcher) {\n          return { params: {}, branch }\n        }\n\n        let params = matcher.match(path)\n\n        if (!params) {\n          return null\n        }\n\n        return { params, branch }\n      },\n    }\n\n    let low = 0\n    let high = branches.length\n    let mid: number\n\n    while (low < high) {\n      mid = (low + high) >>> 1\n\n      if (branches[mid].weight >= branch.weight) {\n        low = mid + 1\n      }\n      else {\n        high = mid\n      }\n    }\n\n    if (def.children) {\n      branches.splice(low, 0, ...create_branches(def.children, branch), branch)\n    }\n    else {\n      branches.splice(low, 0, branch)\n    }\n  }\n\n  return branches\n}\n\nfunction match_branches(path: string, branches: Branch[]): Match | null {\n  path = path.slice(1)\n\n  for (let branch of branches) {\n    let result = branch.match(path)\n\n    if (result) {\n      return result\n    }\n  }\n\n  return null\n}\n\nfunction setup_anchor_events(router: RouterContext) {\n  function handle_anchor_click(e: MouseEvent) {\n    if (\n      e.defaultPrevented\n      || e.button !== 0\n      || e.metaKey\n      || e.altKey\n      || e.ctrlKey\n      || e.shiftKey\n    ) {\n      return\n    }\n\n    let a = e\n      .composedPath()\n      .find(el => el instanceof Node && el.nodeName.toUpperCase() === 'A') as\n      | HTMLAnchorElement\n      | SVGAElement\n      | undefined\n\n    if (!a) {\n      return\n    }\n\n    let svg = a.namespaceURI === 'http://www.w3.org/2000/svg'\n    let href = svg ? (a as SVGAElement).href.baseVal : String(a.href)\n    let target = svg ? (a as SVGAElement).target.baseVal : String(a.target)\n\n    if (target || (!href && !a.hasAttribute('state'))) {\n      return\n    }\n\n    let rel = (a.getAttribute('rel') || '').split(/\\s+/)\n\n    if (a.hasAttribute('download') || (rel && rel.includes('external'))) {\n      return\n    }\n\n    let url = svg ? new URL(href, document.baseURI) : new URL(href)\n\n    if (url.origin !== window.location.origin) {\n      return\n    }\n\n    e.preventDefault()\n\n    router.navigate(url.pathname + url.search + url.hash, {\n      state: a.hasAttribute('state') && JSON.parse(a.getAttribute('state')!) || undefined,\n      replace: a.hasAttribute('replace'),\n    })\n  }\n\n  // ensure delegated event runs first\n  delegateEvents(['click'])\n\n  document.addEventListener('click', handle_anchor_click)\n\n  onCleanup(() => {\n    document.removeEventListener('click', handle_anchor_click)\n  })\n}\n\nlet navigate_buffer: { resolve: () => void, state_delta?: unknown | number, url?: string, replace?: boolean }[] = []\nlet navigate_timeout: number | undefined\n\nfunction navigate(state?: unknown, url?: string, replace?: boolean): Promise<void>\nfunction navigate(delta: number): Promise<void>\nfunction navigate(state_delta?: unknown | number, url?: string, replace?: boolean): Promise<void> {\n  if (navigate_timeout) {\n    let resolve: () => void\n    let promise = new Promise<void>(res => resolve = res)\n\n    navigate_buffer.push({ resolve: resolve!, state_delta, url, replace })\n\n    return promise\n  }\n\n  if (typeof state_delta == 'number') {\n    history.go(state_delta)\n  }\n  else {\n    if (!url) {\n      url == location.pathname + location.search + location.hash\n\n      replace = true\n    }\n\n    if (replace) {\n      history.replaceState(state_delta, '', url)\n    }\n    else {\n      history.pushState(state_delta, '', url)\n    }\n  }\n\n  navigate_timeout = setTimeout(() => {\n    navigate_timeout = undefined\n\n    let next = navigate_buffer.shift()\n\n    if (!next) {\n      return\n    }\n\n    let { resolve, state_delta, url, replace } = next\n\n    navigate(state_delta, url, replace)\n\n    resolve()\n  }, 10)\n\n  return Promise.resolve()\n}\n","import { Component, JSX, children, mergeProps } from 'solid-js'\n\nexport type RouteProps = {\n  path?: string\n  children?: JSX.Element\n  component?: Component<any>\n}\n\nexport let Route: Component<RouteProps> = (props) => {\n  let resolved = children(() => props.children)\n\n  return mergeProps(props, {\n\n    get children() {\n      let children = resolved()\n\n      if (children && !Array.isArray(children)) {\n        children = [children]\n      }\n\n      return children\n    },\n  }) as unknown as JSX.Element\n}\n","import { Accessor, createMemo } from 'solid-js'\n\nimport { Params } from './types'\nimport { use_router, use_route } from './Router'\n\nexport { Router } from './Router'\nexport { Route } from './Route'\n\nexport let use_is_routing = () => use_route().is_routing\n\nexport let use_intent = () => use_route().intent\n\nexport let use_depth = () => {\n  let [state] = use_route().state\n\n  return createMemo(() => state().solidRouter.depth)\n}\n\nexport let use_referrer = () => {\n  let [state] = use_route().state\n\n  return createMemo(() => state().solidRouter.referrer)\n}\n\nexport let use_state = <S = unknown>() => {\n  let [state, set_state] = use_route().state\n\n  return [() => state().solidRouter.state, set_state] as [Accessor<S>, (value: unknown) => void]\n}\n\nexport let use_pathname = () => use_route().pathname\n\nexport let use_search = () => use_route().search\n\nexport let use_search_params = <P extends Params = Params>(): [P, (params: Partial<P>) => void] => use_route().search_params as unknown as [P, (params: Partial<P>) => void]\n\nexport let use_hash = () => use_route().hash\n\nexport let use_params = <P extends Params = Params>() => use_route().url_params as unknown as [P, (params: Partial<P>) => void]\n\nexport let use_navigate = () => use_router().navigate\n\nexport let use_outlet = () => use_route().component\n\ndeclare module 'solid-js' {\n  namespace JSX {\n    interface AnchorHTMLAttributes<T> {\n      state?: string\n      replace?: boolean\n    }\n  }\n}\n"],"names":["params_regex","segments_regex","create_matcher","route","param_defs","matched","pk","weight","_","not_static","name","wild","optional","regex","flags","param","stop","k","prev","path","segments","args","seg","match","right","wild_args","wk","RouterContext","createContext","use_router","ctx","useContext","Error","RouteContext","use_route","undefined","Router","props","is_routing","set_is_routing","createSignal","intent","set_intent","pathname","set_pathname","extract_pathname","location","initial_search","initial_search_params","extract_search","search","set_search","search_params","set_search_params","hash","set_hash","extract_hash","get_state","state","set_state","equals","next","solidRouter","version","depth","route_defs","children","branches","createMemo","defs","Array","isArray","create_branches","set_match","match_branches","branch","createRenderEffect","on","startTransition","resetErrorBoundaries","finally","defer","untrack","next_state","then","value","next_pathname","replace","last_segment_regex","next_search","next_search_params","next_hash","url_params","params","match_","all_params","param_def","static","nextWild","length","join","navigate","url_delta","options","build_search","a","b","referrer","popstate","addEventListener","onCleanup","removeEventListener","setup_anchor_events","matched_branches","leaf","route_def","component","unshift","parent","root_component","_$createComponent","Provider","Child","key","router","child_component","cache","lock","create_params","prev_lock","prev_value","owner","getOwner","map","Map","proxy","Proxy","get","property","has","runWithOwner","set","getOwnPropertyDescriptor","enumerable","configurable","ownKeys","Reflect","history","double_slash_regex","trailing_slash_regex","pathname_regex","url","replaceAll","search_regex","param_regex","match_arr","matchAll","push","v","hash_regex","def","pattern","slice","matcher","low","high","mid","splice","result","handle_anchor_click","e","defaultPrevented","button","metaKey","altKey","ctrlKey","shiftKey","composedPath","find","el","Node","nodeName","toUpperCase","svg","namespaceURI","href","baseVal","String","target","hasAttribute","rel","getAttribute","split","includes","URL","document","baseURI","origin","window","preventDefault","JSON","parse","delegateEvents","navigate_buffer","navigate_timeout","state_delta","resolve","promise","Promise","res","go","replaceState","pushState","setTimeout","shift","Route","resolved","mergeProps","use_is_routing","use_intent","use_depth","use_referrer","use_state","use_pathname","use_search","use_search_params","use_hash","use_params","use_navigate","use_outlet"],"mappings":"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"}